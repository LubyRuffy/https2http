/*
ProxyChecker 是一个用于检测和验证代理服务器的命令行工具。
它可以从 FOFA 搜索引擎获取代理列表，并验证这些代理是否能够正常工作。

=== 使用说明 ===

基本用法：

	go run ./cmd/proxychecker

参数说明：

	-query string
	      FOFA 查询语句 (默认值: type="subdomain" && cert.is_valid=true && domain!="" && title="ERROR: The requested URL could not be retrieved")
	-expr string
	      验证代理的表达式 (默认值: response.Header("Server")=="gws")
	-target string
	      用于测试代理的目标 URL (默认值: https://www.google.com)
	-testProxy string
	      直接测试单个代理（不使用 FOFA 搜索）
	-method string
	      HTTP 请求方法 (默认值: GET)
	-type string
	      代理类型：socks5/http/https/auto (默认值: auto)
	-timeout int
	      请求超时时间（秒） (默认值: 10)
	-workers int
	      并发工作线程数 (默认值: 20)
	-size int
	      FOFA 搜索结果数量 (默认值: 1000)
	-debug
	      启用调试模式 (默认值: false)
	-geo
	      获取有效代理的地理位置信息 (默认值: false)
	-clash string
	      输出 Clash 配置文件路径（如：clash.yaml）
	-clashGroup string
	      Clash 代理组名称 (默认值: proxy)

=== 返回格式说明 ===

程序使用 JSON 格式的日志输出，包含以下几种消息类型：

 1. 进度信息（定期输出）：
    {"time":"2026-01-18T21:13:03.452157+08:00","level":"INFO","msg":"progress","processed":353,"total":1000}
    - processed: 已处理的代理数量
    - total: 总代理数量

 2. 发现有效代理（未启用 -geo）：
    {"time":"2026-01-18T21:13:11.534572+08:00","level":"INFO","msg":"successful proxy","found":true,"host":"https://bulion11356.ru"}
    - host: 代理地址

 3. 发现有效代理（启用 -geo）：
    {"time":"2026-01-18T21:13:11.534572+08:00","level":"INFO","msg":"successful proxy","found":true,"host":"https://bulion11356.ru","country":"US","ip":"1.2.3.4","ipv6":false}
    - host: 代理地址
    - country: 国家代码（如 US, CN, JP 等）
    - ip: 出口 IP 地址
    - ipv6: 是否为 IPv6 地址

 4. 代理有效但获取地理信息失败（启用 -geo）：
    {"time":"2026-01-18T21:13:11.534572+08:00","level":"INFO","msg":"successful proxy but failed to get geo info","found":true,"host":"https://bulion11356.ru","error":"timeout"}

 5. Clash 配置文件保存成功：
    {"time":"2026-01-18T21:13:15.534572+08:00","level":"INFO","msg":"Clash config saved","file":"clash.yaml","proxy_count":5}
    - file: 配置文件路径
    - proxy_count: 有效代理数量

 6. Clash 配置文件保存失败：
    {"time":"2026-01-18T21:13:15.534572+08:00","level":"ERROR","msg":"Failed to save clash config","error":"..."}

 7. 代理检测失败（仅在 debug 模式显示）：
    {"time":"2026-01-18T21:13:11.534572+08:00","level":"DEBUG","msg":"proxy check failed","host":"...","error":"..."}

=== 使用示例 ===

 1. 基本用法（检测 Google 前置代理）：
    go run ./cmd/proxychecker -query 'type="subdomain" && cert.is_valid=true && domain!="" && title="ERROR: The requested URL could not be retrieved"' -expr 'response.Header("Server")=="gws"' -target https://www.google.com -size 100

 2. 检测百度代理：
    go run ./cmd/proxychecker -query 'port="3128"' -expr 'response.Header("Server")=~"(?is)(nginx)"' -target https://www.baidu.com -size 100

 3. 启用地理信息查询：
    go run ./cmd/proxychecker -query 'port="3128"' -expr 'response.Body()=~"(?is)百度"' -target https://www.baidu.com -size 100 -geo

 4. 测试单个代理：
    go run ./cmd/proxychecker -testProxy https://proxy.example.com:443 -expr 'response.Header("Server")=="gws"' -target https://www.google.com

 5. 生成 Clash 配置文件：
    go run ./cmd/proxychecker -query 'port="3128"' -expr 'response.Body()=~"(?is)百度"' -target https://www.baidu.com -size 100 -geo -clash clash.yaml -clashGroup "my-proxies"

 6. 调试模式（显示详细响应信息）：
    go run ./cmd/proxychecker -query 'port="3128"' -expr 'response.Header("Server")=="gws"' -target https://www.google.com -size 10 -debug

=== 表达式说明 ===

可用的表达式变量和函数：
- response.Header("key"): 获取 HTTP 响应头
- response.Body(): 获取响应体内容

表达式示例：
- response.Header("Server")=="gws"
- response.Body()=~"(?is)百度"
- response.Header("Content-Type")=="text/html"

=== 注意事项 ===

1. 需要配置 FOFA API 密钥（通过环境变量或配置文件）
2. 使用 -geo 参数会增加请求时间，因为需要额外访问地理信息查询接口
3. -clash 参数只在找到有效代理时才会生成配置文件
4. 日志输出为 JSON 格式，适合程序化处理

---

关于 gval 不支持 http.Response.Header.Get 的说明：
gval 不支持http.Response.Header.Get，因为Header作为reflect.Map进行了处理，所以，要单独进行一个封装

	gval.reflectSelect (evaluable.go:160) github.com/PaesslerAG/gval
	gval.variable.func1 (evaluable.go:144) github.com/PaesslerAG/gval
	gval.(*Parser).callEvaluable.func1 (evaluable.go:225) github.com/PaesslerAG/gval
	gval.(*infix).initiate.func2.1 (operator.go:92) github.com/PaesslerAG/gval
	gval.Language.EvaluateWithContext (language.go:89) github.com/PaesslerAG/gval
	gval.EvaluateWithContext (gval.go:30) github.com/PaesslerAG/gval
	gval.Evaluate (gval.go:21) github.com/PaesslerAG/gval
	main.isProxy (main.go:41) main
	main.main.func1 (main.go:65) main
	main.main (main.go:73) main
	runtime.main (proc.go:250) runtime
	runtime.goexit (asm_amd64.s:1571) runtime
	 - Async Stack Trace
	<autogenerated>:2
*/
package main

import (
	"crypto/tls"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log/slog"
	"net"
	"net/http"
	"net/url"
	"os"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/LubyRuffy/gofofa"
	"github.com/PaesslerAG/gval"
	"github.com/gammazero/workerpool"
	"gopkg.in/yaml.v3"
)

type ResponsePackage struct {
	resp *http.Response
	body []byte
}

func (rp ResponsePackage) Header(key string) string {
	return rp.resp.Header.Get(key)
}

func (rp ResponsePackage) Body() string {
	return string(rp.body)
}

func NewResponsePackage(resp *http.Response, body []byte) *ResponsePackage {
	return &ResponsePackage{
		resp: resp,
		body: body,
	}
}

// 创建带有代理设置的HTTP客户端
func createHTTPClient(host string, timeout time.Duration) (*http.Client, error) {
	proxyURL, err := url.Parse(host)
	if err != nil {
		return nil, err
	}

	return &http.Client{
		Transport: &http.Transport{
			Proxy:                 http.ProxyURL(proxyURL),
			TLSClientConfig:       &tls.Config{InsecureSkipVerify: true},
			ResponseHeaderTimeout: timeout,
			IdleConnTimeout:       timeout,
			TLSHandshakeTimeout:   timeout,
			ExpectContinueTimeout: timeout,
		},
	}, nil
}

// 发送HTTP请求并获取响应体
func sendHTTPRequest(client *http.Client, method, url string) (*http.Response, []byte, error) {
	req, err := http.NewRequest(method, url, nil)
	if err != nil {
		return nil, nil, err
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, nil, err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, nil, err
	}

	return resp, body, nil
}

// GeoInfo 地理位置信息
type GeoInfo struct {
	Country string `json:"country"`
	IP      string `json:"ip"`
}

// IsIPv6 判断是否为 IPv6 地址
func (g GeoInfo) IsIPv6() bool {
	ip := net.ParseIP(g.IP)
	if ip == nil {
		return false
	}
	return ip.To4() == nil
}

// ClashProxy Clash 代理配置
type ClashProxy struct {
	Name   string `yaml:"name"`
	Type   string `yaml:"type"`
	Server string `yaml:"server"`
	Port   int    `yaml:"port"`
	TLS    bool   `yaml:"tls,omitempty"`
}

// ClashProxyGroup Clash 代理组配置
type ClashProxyGroup struct {
	Name    string   `yaml:"name"`
	Type    string   `yaml:"type"`
	Proxies []string `yaml:"proxies"`
}

// ClashConfig Clash 配置文件结构
type ClashConfig struct {
	Proxies     []ClashProxy      `yaml:"proxies"`
	ProxyGroups []ClashProxyGroup `yaml:"proxy-groups"`
}

// ValidProxy 有效代理信息
type ValidProxy struct {
	Host    string
	GeoInfo *GeoInfo
}

// ValidProxyCollector 线程安全的代理收集器
type ValidProxyCollector struct {
	mu      sync.Mutex
	proxies []ValidProxy
}

// Add 添加有效代理
func (c *ValidProxyCollector) Add(host string, geoInfo *GeoInfo) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.proxies = append(c.proxies, ValidProxy{Host: host, GeoInfo: geoInfo})
}

// GetAll 获取所有有效代理
func (c *ValidProxyCollector) GetAll() []ValidProxy {
	c.mu.Lock()
	defer c.mu.Unlock()
	result := make([]ValidProxy, len(c.proxies))
	copy(result, c.proxies)
	return result
}

// ParseProxyURL 解析代理URL，返回 server, port, tls, proxyType
func ParseProxyURL(proxyURL string) (server string, port int, useTLS bool, proxyType string, err error) {
	u, err := url.Parse(proxyURL)
	if err != nil {
		return "", 0, false, "", err
	}

	server = u.Hostname()
	portStr := u.Port()

	// 根据 scheme 确定默认端口和 tls
	switch u.Scheme {
	case "https":
		useTLS = true
		proxyType = "http"
		if portStr == "" {
			port = 443
		}
	case "http":
		useTLS = false
		proxyType = "http"
		if portStr == "" {
			port = 80
		}
	case "socks5":
		useTLS = false
		proxyType = "socks5"
		if portStr == "" {
			port = 1080
		}
	default:
		proxyType = "http"
		if portStr == "" {
			port = 80
		}
	}

	if portStr != "" {
		var p int
		_, err = fmt.Sscanf(portStr, "%d", &p)
		if err != nil {
			return "", 0, false, "", err
		}
		port = p
	}

	return server, port, useTLS, proxyType, nil
}

// GenerateProxyName 生成代理名称
func GenerateProxyName(index int, geoInfo *GeoInfo) string {
	if geoInfo != nil && geoInfo.Country != "" {
		ipSuffix := ""
		if geoInfo.IsIPv6() {
			ipSuffix = "-v6"
		}
		return fmt.Sprintf("%s%s-%d", geoInfo.Country, ipSuffix, index)
	}
	return fmt.Sprintf("proxy-%d", index)
}

// GenerateClashConfig 生成 Clash 配置
func GenerateClashConfig(proxies []ValidProxy, groupName string) (*ClashConfig, error) {
	if len(proxies) == 0 {
		return nil, fmt.Errorf("no valid proxies to generate config")
	}

	config := &ClashConfig{
		Proxies:     make([]ClashProxy, 0, len(proxies)),
		ProxyGroups: make([]ClashProxyGroup, 0, 1),
	}

	proxyNames := make([]string, 0, len(proxies))

	for i, p := range proxies {
		server, port, useTLS, proxyType, err := ParseProxyURL(p.Host)
		if err != nil {
			continue
		}

		name := GenerateProxyName(i+1, p.GeoInfo)
		proxyNames = append(proxyNames, name)

		clashProxy := ClashProxy{
			Name:   name,
			Type:   proxyType,
			Server: server,
			Port:   port,
		}
		if useTLS {
			clashProxy.TLS = true
		}

		config.Proxies = append(config.Proxies, clashProxy)
	}

	// 添加代理组
	config.ProxyGroups = append(config.ProxyGroups, ClashProxyGroup{
		Name:    groupName,
		Type:    "select",
		Proxies: proxyNames,
	})

	return config, nil
}

// SaveClashConfig 保存 Clash 配置到文件
func SaveClashConfig(config *ClashConfig, filename string) error {
	data, err := yaml.Marshal(config)
	if err != nil {
		return fmt.Errorf("failed to marshal clash config: %w", err)
	}

	err = os.WriteFile(filename, data, 0644)
	if err != nil {
		return fmt.Errorf("failed to write clash config file: %w", err)
	}

	return nil
}

func getGeoInfo(host string, timeout time.Duration) (*GeoInfo, error) {
	client, err := createHTTPClient(host, timeout)
	if err != nil {
		return nil, err
	}

	_, body, err := sendHTTPRequest(client, "GET", "http://ip.bmh.im/c")
	if err != nil {
		return nil, err
	}

	// 解析JSON获取country和ip
	var geoInfo GeoInfo
	if err := json.Unmarshal(body, &geoInfo); err != nil {
		return nil, err
	}

	if geoInfo.Country == "" {
		return nil, fmt.Errorf("invalid country info")
	}

	return &geoInfo, nil
}

func isProxyHTTP(method, host, checkUrl, expr string, timeout time.Duration, debug bool) (bool, error) {
	slog.Debug("checking proxy", "host", host)

	client, err := createHTTPClient(host, timeout)
	if err != nil {
		return false, err
	}

	resp, body, err := sendHTTPRequest(client, method, checkUrl)
	if err != nil {
		return false, err
	}

	slog.Debug("proxy response", "host", host, "headers", resp.Header, "body", hex.Dump(body))

	value, err := gval.Evaluate(expr,
		map[string]interface{}{
			"response": NewResponsePackage(resp, body),
		},
		gval.Function("body", func(arguments ...interface{}) (interface{}, error) {
			return string(body), err
		}))
	if err != nil {
		fmt.Println(err)
	}

	return value.(bool), nil
}

// FixURL 补充完整url，主要用于ip:port变成url
func FixURL(v string, proxyType string) string {
	if !strings.Contains(v, "://") {
		host, port, _ := net.SplitHostPort(v)
		if proxyType != "" && proxyType != "auto" {
			return proxyType + "://" + v
		}
		switch port {
		case "80":
			v = "http://" + host
		case "443":
			v = "https://" + host
		default:
			v = "http://" + v
		}
	} else {
		u, err := url.Parse(v)
		if err != nil {
			return v
		}
		//v = u.String() 不会过滤标准端口
		v = u.Scheme + "://" + u.Hostname()
		port := u.Port()
		var defaultPort bool
		switch u.Scheme {
		case "http":
			if port == "80" {
				defaultPort = true
			}
		case "https":
			if port == "443" {
				defaultPort = true
			}
		}
		if !defaultPort && port != "" {
			v += ":" + port
		}

		v += u.Path
		if len(u.RawQuery) > 0 {
			v += "?" + u.RawQuery
		}
	}
	return v
}

func main() {
	query := flag.String("query", `type="subdomain" && cert.is_valid=true && domain!="" && title="ERROR: The requested URL could not be retrieved"`, "fofa query")
	expr := flag.String("expr", `response.Header("Server")=="gws"`, `check expr`) // `response.Header.Get("Server")=="gws"`
	checkTarget := flag.String("target", `https://www.google.com`, `target to visit`)
	testProxy := flag.String("testProxy", ``, `testProxy only for test`)
	method := flag.String("method", `GET`, `method to request`)
	proxyType := flag.String("type", `auto`, `could be: socks5/http/https/auto`)
	timeout := flag.Int("timeout", 10, `timeout for request`)
	workers := flag.Int("workers", 20, `workers to run`)
	size := flag.Int("size", 1000, `workers to run`)
	debug := flag.Bool("debug", false, `workers to run`)
	geo := flag.Bool("geo", false, `enable geo check for valid proxies`)
	clashFile := flag.String("clash", ``, `output clash config file path (e.g., clash.yaml)`)
	clashGroup := flag.String("clashGroup", `proxy`, `clash proxy group name`)
	flag.Parse()

	// 设置 slog 为 JSON 格式
	opts := &slog.HandlerOptions{
		Level: slog.LevelInfo,
	}
	if *debug {
		opts.Level = slog.LevelDebug
	}
	logger := slog.New(slog.NewJSONHandler(os.Stdout, opts))
	slog.SetDefault(logger)

	timeOutDuration := time.Second * time.Duration(*timeout)
	lastUpdateLog := time.Now()

	var allsize int64
	var processed int64

	// 创建代理收集器
	collector := &ValidProxyCollector{}

	testOne := func(host string) {
		var ok bool
		var err error

		host = FixURL(host, *proxyType)
		ok, err = isProxyHTTP(*method, host, *checkTarget, *expr, timeOutDuration, *debug)

		if err == nil && ok {
			var geoInfo *GeoInfo
			if *geo {
				// 获取地理信息
				geoInfo, err = getGeoInfo(host, timeOutDuration)
				if err != nil {
					slog.Info("successful proxy but failed to get geo info",
						"found", true,
						"host", host,
						"error", err.Error())
				} else {
					slog.Info("successful proxy",
						"found", true,
						"host", host,
						"country", geoInfo.Country,
						"ip", geoInfo.IP,
						"ipv6", geoInfo.IsIPv6())
				}
			} else {
				slog.Info("successful proxy",
					"found", true,
					"host", host)
			}
			// 收集有效代理用于生成 Clash 配置
			if *clashFile != "" {
				collector.Add(host, geoInfo)
			}
		} else {
			slog.Debug("proxy check failed", "host", host, "error", err)
		}

		if processed%100 == 0 || time.Since(lastUpdateLog) > time.Second*5 {
			slog.Info("progress", "processed", processed, "total", allsize)
			lastUpdateLog = time.Now()
		}
	}

	if len(*testProxy) > 0 {
		testOne(*testProxy)

		// 如果指定了 clash 输出文件，生成配置
		if *clashFile != "" {
			proxies := collector.GetAll()
			if len(proxies) > 0 {
				config, err := GenerateClashConfig(proxies, *clashGroup)
				if err != nil {
					slog.Error("Failed to generate clash config", "error", err.Error())
				} else {
					if err := SaveClashConfig(config, *clashFile); err != nil {
						slog.Error("Failed to save clash config", "error", err.Error())
					} else {
						slog.Info("Clash config saved",
							"file", *clashFile,
							"proxy_count", len(proxies))
					}
				}
			}
		}
		return
	}

	fofa, err := gofofa.NewClient()
	if err != nil {
		panic(err)
	}

	res, err := fofa.HostSearch(*query, *size, []string{"host,ip"})
	if err != nil {
		panic(err)
	}

	allsize = int64(len(res))
	wp := workerpool.New(*workers)
	ipMap := make(map[string]bool)
	for _, record := range res {
		host := record[0]
		ip := record[1]
		if v, ok := ipMap[ip]; ok && v {
			atomic.AddInt64(&processed, 1)
			continue
		}
		ipMap[ip] = true
		wp.Submit(func() {
			defer atomic.AddInt64(&processed, 1)
			testOne(host)
		})
	}
	wp.StopWait()

	// 生成 Clash 配置文件
	if *clashFile != "" {
		proxies := collector.GetAll()
		if len(proxies) > 0 {
			config, err := GenerateClashConfig(proxies, *clashGroup)
			if err != nil {
				slog.Error("Failed to generate clash config", "error", err.Error())
			} else {
				if err := SaveClashConfig(config, *clashFile); err != nil {
					slog.Error("Failed to save clash config", "error", err.Error())
				} else {
					slog.Info("Clash config saved",
						"file", *clashFile,
						"proxy_count", len(proxies))
				}
			}
		} else {
			slog.Info("No valid proxies found, clash config not generated")
		}
	}
}
