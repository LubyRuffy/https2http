// 检查cert.is_valid=true && type="subdomain" && title="ERROR: The requested URL could not be retrieved" && domain!="" && body="Some aspect of the requested URL is incorrect"
/*
gval 不支持http.Response.Header.Get，因为Header作为reflect.Map进行了处理，所以，要单独进行一个封装
	gval.reflectSelect (evaluable.go:160) github.com/PaesslerAG/gval
	gval.variable.func1 (evaluable.go:144) github.com/PaesslerAG/gval
	gval.(*Parser).callEvaluable.func1 (evaluable.go:225) github.com/PaesslerAG/gval
	gval.(*infix).initiate.func2.1 (operator.go:92) github.com/PaesslerAG/gval
	gval.Language.EvaluateWithContext (language.go:89) github.com/PaesslerAG/gval
	gval.EvaluateWithContext (gval.go:30) github.com/PaesslerAG/gval
	gval.Evaluate (gval.go:21) github.com/PaesslerAG/gval
	main.isProxy (main.go:41) main
	main.main.func1 (main.go:65) main
	main.main (main.go:73) main
	runtime.main (proc.go:250) runtime
	runtime.goexit (asm_amd64.s:1571) runtime
	 - Async Stack Trace
	<autogenerated>:2

*/
package main

import (
	"crypto/tls"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"net/url"
	"os"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/LubyRuffy/gofofa"
	"github.com/PaesslerAG/gval"
	"github.com/gammazero/workerpool"
	"gopkg.in/yaml.v3"
)

type ResponsePackage struct {
	resp *http.Response
	body []byte
}

func (rp ResponsePackage) Header(key string) string {
	return rp.resp.Header.Get(key)
}

func (rp ResponsePackage) Body() string {
	return string(rp.body)
}

func NewResponsePackage(resp *http.Response, body []byte) *ResponsePackage {
	return &ResponsePackage{
		resp: resp,
		body: body,
	}
}

// 创建带有代理设置的HTTP客户端
func createHTTPClient(host string, timeout time.Duration) (*http.Client, error) {
	proxyURL, err := url.Parse(host)
	if err != nil {
		return nil, err
	}

	return &http.Client{
		Transport: &http.Transport{
			Proxy:                 http.ProxyURL(proxyURL),
			TLSClientConfig:       &tls.Config{InsecureSkipVerify: true},
			ResponseHeaderTimeout: timeout,
			IdleConnTimeout:       timeout,
			TLSHandshakeTimeout:   timeout,
			ExpectContinueTimeout: timeout,
		},
	}, nil
}

// 发送HTTP请求并获取响应体
func sendHTTPRequest(client *http.Client, method, url string) (*http.Response, []byte, error) {
	req, err := http.NewRequest(method, url, nil)
	if err != nil {
		return nil, nil, err
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, nil, err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, nil, err
	}

	return resp, body, nil
}

// GeoInfo 地理位置信息
type GeoInfo struct {
	Country string `json:"country"`
	IP      string `json:"ip"`
}

// IsIPv6 判断是否为 IPv6 地址
func (g GeoInfo) IsIPv6() bool {
	ip := net.ParseIP(g.IP)
	if ip == nil {
		return false
	}
	return ip.To4() == nil
}

// ClashProxy Clash 代理配置
type ClashProxy struct {
	Name   string `yaml:"name"`
	Type   string `yaml:"type"`
	Server string `yaml:"server"`
	Port   int    `yaml:"port"`
	TLS    bool   `yaml:"tls,omitempty"`
}

// ClashProxyGroup Clash 代理组配置
type ClashProxyGroup struct {
	Name    string   `yaml:"name"`
	Type    string   `yaml:"type"`
	Proxies []string `yaml:"proxies"`
}

// ClashConfig Clash 配置文件结构
type ClashConfig struct {
	Proxies     []ClashProxy      `yaml:"proxies"`
	ProxyGroups []ClashProxyGroup `yaml:"proxy-groups"`
}

// ValidProxy 有效代理信息
type ValidProxy struct {
	Host    string
	GeoInfo *GeoInfo
}

// ValidProxyCollector 线程安全的代理收集器
type ValidProxyCollector struct {
	mu      sync.Mutex
	proxies []ValidProxy
}

// Add 添加有效代理
func (c *ValidProxyCollector) Add(host string, geoInfo *GeoInfo) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.proxies = append(c.proxies, ValidProxy{Host: host, GeoInfo: geoInfo})
}

// GetAll 获取所有有效代理
func (c *ValidProxyCollector) GetAll() []ValidProxy {
	c.mu.Lock()
	defer c.mu.Unlock()
	result := make([]ValidProxy, len(c.proxies))
	copy(result, c.proxies)
	return result
}

// ParseProxyURL 解析代理URL，返回 server, port, tls, proxyType
func ParseProxyURL(proxyURL string) (server string, port int, useTLS bool, proxyType string, err error) {
	u, err := url.Parse(proxyURL)
	if err != nil {
		return "", 0, false, "", err
	}

	server = u.Hostname()
	portStr := u.Port()

	// 根据 scheme 确定默认端口和 tls
	switch u.Scheme {
	case "https":
		useTLS = true
		proxyType = "http"
		if portStr == "" {
			port = 443
		}
	case "http":
		useTLS = false
		proxyType = "http"
		if portStr == "" {
			port = 80
		}
	case "socks5":
		useTLS = false
		proxyType = "socks5"
		if portStr == "" {
			port = 1080
		}
	default:
		proxyType = "http"
		if portStr == "" {
			port = 80
		}
	}

	if portStr != "" {
		var p int
		_, err = fmt.Sscanf(portStr, "%d", &p)
		if err != nil {
			return "", 0, false, "", err
		}
		port = p
	}

	return server, port, useTLS, proxyType, nil
}

// GenerateProxyName 生成代理名称
func GenerateProxyName(index int, geoInfo *GeoInfo) string {
	if geoInfo != nil && geoInfo.Country != "" {
		ipSuffix := ""
		if geoInfo.IsIPv6() {
			ipSuffix = "-v6"
		}
		return fmt.Sprintf("%s%s-%d", geoInfo.Country, ipSuffix, index)
	}
	return fmt.Sprintf("proxy-%d", index)
}

// GenerateClashConfig 生成 Clash 配置
func GenerateClashConfig(proxies []ValidProxy, groupName string) (*ClashConfig, error) {
	if len(proxies) == 0 {
		return nil, fmt.Errorf("no valid proxies to generate config")
	}

	config := &ClashConfig{
		Proxies:     make([]ClashProxy, 0, len(proxies)),
		ProxyGroups: make([]ClashProxyGroup, 0, 1),
	}

	proxyNames := make([]string, 0, len(proxies))

	for i, p := range proxies {
		server, port, useTLS, proxyType, err := ParseProxyURL(p.Host)
		if err != nil {
			continue
		}

		name := GenerateProxyName(i+1, p.GeoInfo)
		proxyNames = append(proxyNames, name)

		clashProxy := ClashProxy{
			Name:   name,
			Type:   proxyType,
			Server: server,
			Port:   port,
		}
		if useTLS {
			clashProxy.TLS = true
		}

		config.Proxies = append(config.Proxies, clashProxy)
	}

	// 添加代理组
	config.ProxyGroups = append(config.ProxyGroups, ClashProxyGroup{
		Name:    groupName,
		Type:    "select",
		Proxies: proxyNames,
	})

	return config, nil
}

// SaveClashConfig 保存 Clash 配置到文件
func SaveClashConfig(config *ClashConfig, filename string) error {
	data, err := yaml.Marshal(config)
	if err != nil {
		return fmt.Errorf("failed to marshal clash config: %w", err)
	}

	err = os.WriteFile(filename, data, 0644)
	if err != nil {
		return fmt.Errorf("failed to write clash config file: %w", err)
	}

	return nil
}

func getGeoInfo(host string, timeout time.Duration) (*GeoInfo, error) {
	client, err := createHTTPClient(host, timeout)
	if err != nil {
		return nil, err
	}

	_, body, err := sendHTTPRequest(client, "GET", "http://ip.bmh.im/c")
	if err != nil {
		return nil, err
	}

	// 解析JSON获取country和ip
	var geoInfo GeoInfo
	if err := json.Unmarshal(body, &geoInfo); err != nil {
		return nil, err
	}

	if geoInfo.Country == "" {
		return nil, fmt.Errorf("invalid country info")
	}

	return &geoInfo, nil
}

func isProxyHTTP(method, host, checkUrl, expr string, timeout time.Duration, debug bool) (bool, error) {
	if debug {
		log.Println("checking ", host)
	}

	client, err := createHTTPClient(host, timeout)
	if err != nil {
		return false, err
	}

	resp, body, err := sendHTTPRequest(client, method, checkUrl)
	if err != nil {
		return false, err
	}

	if debug {
		log.Printf("%s: %v\n%s\n", host, resp.Header, hex.Dump(body))
	}

	value, err := gval.Evaluate(expr,
		map[string]interface{}{
			"response": NewResponsePackage(resp, body),
		},
		gval.Function("body", func(arguments ...interface{}) (interface{}, error) {
			return string(body), err
		}))
	if err != nil {
		fmt.Println(err)
	}

	return value.(bool), nil
}

// FixURL 补充完整url，主要用于ip:port变成url
func FixURL(v string, proxyType string) string {
	if !strings.Contains(v, "://") {
		host, port, _ := net.SplitHostPort(v)
		if proxyType != "" && proxyType != "auto" {
			return proxyType + "://" + v
		}
		switch port {
		case "80":
			v = "http://" + host
		case "443":
			v = "https://" + host
		default:
			v = "http://" + v
		}
	} else {
		u, err := url.Parse(v)
		if err != nil {
			return v
		}
		//v = u.String() 不会过滤标准端口
		v = u.Scheme + "://" + u.Hostname()
		port := u.Port()
		var defaultPort bool
		switch u.Scheme {
		case "http":
			if port == "80" {
				defaultPort = true
			}
		case "https":
			if port == "443" {
				defaultPort = true
			}
		}
		if !defaultPort && port != "" {
			v += ":" + port
		}

		v += u.Path
		if len(u.RawQuery) > 0 {
			v += "?" + u.RawQuery
		}
	}
	return v
}

func main() {
	query := flag.String("query", `type="subdomain" && cert.is_valid=true && domain!="" && title="ERROR: The requested URL could not be retrieved"`, "fofa query")
	expr := flag.String("expr", `response.Header("Server")=="gws"`, `check expr`) // `response.Header.Get("Server")=="gws"`
	checkTarget := flag.String("target", `https://www.google.com`, `target to visit`)
	testProxy := flag.String("testProxy", ``, `testProxy only for test`)
	method := flag.String("method", `GET`, `method to request`)
	proxyType := flag.String("type", `auto`, `could be: socks5/http/https/auto`)
	timeout := flag.Int("timeout", 10, `timeout for request`)
	workers := flag.Int("workers", 20, `workers to run`)
	size := flag.Int("size", 1000, `workers to run`)
	debug := flag.Bool("debug", false, `workers to run`)
	geo := flag.Bool("geo", false, `enable geo check for valid proxies`)
	clashFile := flag.String("clash", ``, `output clash config file path (e.g., clash.yaml)`)
	clashGroup := flag.String("clashGroup", `proxy`, `clash proxy group name`)
	flag.Parse()

	timeOutDuration := time.Second * time.Duration(*timeout)

	var allsize int64
	var processed int64

	// 创建代理收集器
	collector := &ValidProxyCollector{}

	testOne := func(host string) {
		var ok bool
		var err error

		host = FixURL(host, *proxyType)
		ok, err = isProxyHTTP(*method, host, *checkTarget, *expr, timeOutDuration, *debug)

		if err == nil && ok {
			var geoInfo *GeoInfo
			if *geo {
				// 获取地理信息
				geoInfo, err = getGeoInfo(host, timeOutDuration)
				if err != nil {
					fmt.Printf("\nsuccessful proxy: %s, but failed to get geo info: %v\n", host, err)
				} else {
					ipType := ""
					if geoInfo.IsIPv6() {
						ipType = " [IPv6]"
					}
					fmt.Printf("\nsuccessful proxy: %s, country: %s, ip: %s%s\n", host, geoInfo.Country, geoInfo.IP, ipType)
				}
			} else {
				fmt.Println("\nsuccessful proxy:", host)
			}

			// 收集有效代理用于生成 Clash 配置
			if *clashFile != "" {
				collector.Add(host, geoInfo)
			}
		} else {
			fmt.Printf(".")
			if processed%100 == 0 {
				fmt.Printf("      %d/%d \r", processed, allsize)
			}
			//log.Println("not proxy:", host)
		}
	}

	if len(*testProxy) > 0 {
		testOne(*testProxy)

		// 如果指定了 clash 输出文件，生成配置
		if *clashFile != "" {
			proxies := collector.GetAll()
			if len(proxies) > 0 {
				config, err := GenerateClashConfig(proxies, *clashGroup)
				if err != nil {
					log.Printf("Failed to generate clash config: %v\n", err)
				} else {
					if err := SaveClashConfig(config, *clashFile); err != nil {
						log.Printf("Failed to save clash config: %v\n", err)
					} else {
						fmt.Printf("\nClash config saved to %s with %d proxies\n", *clashFile, len(proxies))
					}
				}
			}
		}
		return
	}

	fofa, err := gofofa.NewClient()
	if err != nil {
		panic(err)
	}

	res, err := fofa.HostSearch(*query, *size, []string{"host,ip"})
	if err != nil {
		panic(err)
	}

	allsize = int64(len(res))
	wp := workerpool.New(*workers)
	ipMap := make(map[string]bool)
	for _, record := range res {
		host := record[0]
		ip := record[1]
		if v, ok := ipMap[ip]; ok && v {
			atomic.AddInt64(&processed, 1)
			continue
		}
		ipMap[ip] = true
		wp.Submit(func() {
			defer atomic.AddInt64(&processed, 1)
			testOne(host)
		})
	}
	wp.StopWait()

	// 生成 Clash 配置文件
	if *clashFile != "" {
		proxies := collector.GetAll()
		if len(proxies) > 0 {
			config, err := GenerateClashConfig(proxies, *clashGroup)
			if err != nil {
				log.Printf("Failed to generate clash config: %v\n", err)
			} else {
				if err := SaveClashConfig(config, *clashFile); err != nil {
					log.Printf("Failed to save clash config: %v\n", err)
				} else {
					fmt.Printf("\nClash config saved to %s with %d proxies\n", *clashFile, len(proxies))
				}
			}
		} else {
			fmt.Println("\nNo valid proxies found, clash config not generated")
		}
	}
}
