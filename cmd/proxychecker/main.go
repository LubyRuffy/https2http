// 检查cert.is_valid=true && type="subdomain" && title="ERROR: The requested URL could not be retrieved" && domain!="" && body="Some aspect of the requested URL is incorrect"
/*
gval 不支持http.Response.Header.Get，因为Header作为reflect.Map进行了处理，所以，要单独进行一个封装
	gval.reflectSelect (evaluable.go:160) github.com/PaesslerAG/gval
	gval.variable.func1 (evaluable.go:144) github.com/PaesslerAG/gval
	gval.(*Parser).callEvaluable.func1 (evaluable.go:225) github.com/PaesslerAG/gval
	gval.(*infix).initiate.func2.1 (operator.go:92) github.com/PaesslerAG/gval
	gval.Language.EvaluateWithContext (language.go:89) github.com/PaesslerAG/gval
	gval.EvaluateWithContext (gval.go:30) github.com/PaesslerAG/gval
	gval.Evaluate (gval.go:21) github.com/PaesslerAG/gval
	main.isProxy (main.go:41) main
	main.main.func1 (main.go:65) main
	main.main (main.go:73) main
	runtime.main (proc.go:250) runtime
	runtime.goexit (asm_amd64.s:1571) runtime
	 - Async Stack Trace
	<autogenerated>:2

*/
package main

import (
	"crypto/tls"
	"encoding/hex"
	"flag"
	"fmt"
	"github.com/LubyRuffy/gofofa"
	"github.com/PaesslerAG/gval"
	"github.com/gammazero/workerpool"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"net/url"
	"strings"
	"sync/atomic"
	"time"
)

type ResponsePackage struct {
	resp *http.Response
	body []byte
}

func (rp ResponsePackage) Header(key string) string {
	return rp.resp.Header.Get(key)
}

func (rp ResponsePackage) Body() string {
	return string(rp.body)
}

func NewResponsePackage(resp *http.Response, body []byte) *ResponsePackage {
	return &ResponsePackage{
		resp: resp,
		body: body,
	}
}

func isProxyHTTP(method, host, checkUrl, expr string, timeout time.Duration, debug bool) (bool, error) {
	if debug {
		log.Println("checking ", host)
	}

	proxyURL, err := url.Parse(host)
	if err != nil {
		return false, err
	}

	httpClient := &http.Client{
		Transport: &http.Transport{
			Proxy:                 http.ProxyURL(proxyURL),
			TLSClientConfig:       &tls.Config{InsecureSkipVerify: true},
			ResponseHeaderTimeout: timeout,
			IdleConnTimeout:       timeout,
			TLSHandshakeTimeout:   timeout,
			ExpectContinueTimeout: timeout,
		},
	}
	req, err := http.NewRequest(method, checkUrl, nil)
	if err != nil {
		return false, err
	}

	resp, err := httpClient.Do(req)
	if err != nil {
		return false, err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)

	if debug {
		log.Printf("%s: %v\n%s\n", host, resp.Header, hex.Dump(body))
	}

	value, err := gval.Evaluate(expr,
		map[string]interface{}{
			"response": NewResponsePackage(resp, body),
		},
		gval.Function("body", func(arguments ...interface{}) (interface{}, error) {
			return string(body), err
		}))
	if err != nil {
		fmt.Println(err)
	}

	return value.(bool), nil
}

// FixURL 补充完整url，主要用于ip:port变成url
func FixURL(v string, proxyType string) string {
	if !strings.Contains(v, "://") {
		host, port, _ := net.SplitHostPort(v)
		if proxyType != "" && proxyType != "auto" {
			return proxyType + "://" + v
		}
		switch port {
		case "80":
			v = "http://" + host
		case "443":
			v = "https://" + host
		default:
			v = "http://" + v
		}
	} else {
		u, err := url.Parse(v)
		if err != nil {
			return v
		}
		//v = u.String() 不会过滤标准端口
		v = u.Scheme + "://" + u.Hostname()
		var defaultPort bool
		switch u.Scheme {
		case "http":
			if u.Port() == "80" {
				defaultPort = true
			}
		case "https":
			if u.Port() == "443" {
				defaultPort = true
			}
		}
		if !defaultPort {
			v += ":" + u.Port()
		}

		v += u.Path
		if len(u.RawQuery) > 0 {
			v += "?" + u.RawQuery
		}
	}
	return v
}

func main() {
	query := flag.String("query", `type="subdomain" && cert.is_valid=true && domain!="" && title="ERROR: The requested URL could not be retrieved"`, "fofa query")
	expr := flag.String("expr", `response.Header("Server")=="gws"`, `check expr`) // `response.Header.Get("Server")=="gws"`
	checkTarget := flag.String("target", `https://www.google.com`, `target to visit`)
	testProxy := flag.String("testProxy", ``, `testProxy only for test`)
	method := flag.String("method", `GET`, `method to request`)
	proxyType := flag.String("type", `auto`, `could be: socks5/http/https/auto`)
	timeout := flag.Int("timeout", 10, `timeout for request`)
	workers := flag.Int("workers", 20, `workers to run`)
	size := flag.Int("size", 1000, `workers to run`)
	debug := flag.Bool("debug", false, `workers to run`)
	flag.Parse()

	timeOutDuration := time.Second * time.Duration(*timeout)

	var allsize int64
	var processed int64

	testOne := func(host string) {
		var ok bool
		var err error

		host = FixURL(host, *proxyType)
		ok, err = isProxyHTTP(*method, host, *checkTarget, *expr, timeOutDuration, *debug)

		if err == nil && ok {
			fmt.Println("\nsuccessful proxy:", host)
		} else {
			fmt.Printf(".")
			if processed%100 == 0 {
				fmt.Printf("      %d/%d \r", processed, allsize)
			}
			//log.Println("not proxy:", host)
		}
	}

	if len(*testProxy) > 0 {
		testOne(*testProxy)
		return

	}

	fofa, err := gofofa.NewClient()
	if err != nil {
		panic(err)
	}

	res, err := fofa.HostSearch(*query, *size, []string{"host,ip"})
	if err != nil {
		panic(err)
	}

	allsize = int64(len(res))
	wp := workerpool.New(*workers)
	ipMap := make(map[string]bool)
	for _, record := range res {
		host := record[0]
		ip := record[1]
		if v, ok := ipMap[ip]; ok && v {
			atomic.AddInt64(&processed, 1)
			continue
		}
		ipMap[ip] = true
		wp.Submit(func() {
			defer atomic.AddInt64(&processed, 1)
			testOne(host)
		})
	}
	wp.StopWait()

}
